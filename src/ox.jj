/**

oxdoc (c) Copyright 2005 by Y. Zwols [yori@brown.edu]

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

**/

PARSER_BEGIN(Parser)

import java.util.*;
import java.io.*;

  public class Parser {

	private OxFile file = null;
	private OxProject project = null;

  	public Parser(java.io.InputStream stream, OxFile file, OxProject project) {
     		this(stream, null);
		this.file = file; 
		this.project = project;
  	}

  }

PARSER_END(Parser)

SKIP : {
 " "
|  "\t"
|  "\n"
|  "\r"
|  <"#"  (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
|  <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
}

SPECIAL_TOKEN : {
 <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}

TOKEN : {
 <INTEGER_LITERAL: <DECIMAL_LITERAL> (["l","L"])? | <HEX_LITERAL> (["l","L"])? | <OCTAL_LITERAL> (["l","L"])?>
|  <#DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])*>
|  <#HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+>
|  <#OCTAL_LITERAL: "0" (["0"-"7"])*>
|  <FLOATING_POINT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])? | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])? | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])? | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"] >
|  <#EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+>
|  <CHARACTER_LITERAL: "\'" (~["\'","\\","\n","\r"] | "\\" (["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])? | ["0"-"3"] ["0"-"7"] ["0"-"7"])) "\'">
|  <STRING_LITERAL: "\"" (~["\"","\\","\n","\r"] | "\\" (["x","n","t","b","r","f","{","}","\\","\'","\""] | ["0"-"7"] (["0"-"7"])? | ["0"-"3"] ["0"-"7"] ["0"-"7"]))* "\"">
}

TOKEN : {
	<CONTINUE: "continue"> |
	<DECL: "decl"> |
	<DFLT: "default"> |
	<SWITCH: "switch"> |
	<RETURN: "return"> |
	<STATIC: "static"> |
	<WHILE: "while"> |
	<NAN: ".NaN"> |
	<INF: ".Inf"> |
	<BREAK: "break"> |
	<NEW: "new"> | 
	<DELETE: "delete"> | 
	<CONST: "const"> |
	<CLASS: "class"> |
	<EXTERN: "extern"> |
	<VIRTUAL: "virtual"> |
	<NAMESPACE: "namespace"> |
	<ELSE: "else"> |
	<CASE: "case"> |
	<ENUM: "enum"> |
	<FOR: "for"> |
	<IF: "if"> |
	<DO: "do">
}

TOKEN : {
 <IDENTIFIER: <LETTER> (<LETTER> | <DIGIT>)*>
|  <#LETTER: ["$","A"-"Z","_","a"-"z"]>
|  <#DIGIT: ["0"-"9"]>
}

void OxFileDefinition() : {}
{
	{
		/* Try and get the first special token in the file */
		Token t = getToken(1);
		if ((t != null) && t.specialToken != null) {
			Token tmp_t = t.specialToken;
			while (tmp_t.specialToken != null) tmp_t = tmp_t.specialToken;
			if (tmp_t.beginLine == 1)
				file.setComment(tmp_t.image);
		}
	}
	
	( NamespaceDeclaration() |
	  NamespaceDefinition() )+
}

void NamespaceDefinition() : {}
{
	( LOOKAHEAD( FunctionDeclaration() ) FunctionDeclaration() |
	  LOOKAHEAD(2)
	  ExternFunctionDeclaration() |
	  LOOKAHEAD( FunctionDefinition() ) FunctionDefinition() |
	  ClassDefinition() |
	  DeclarationStatement() )
}

void NamespaceDeclaration() : {}
{
	<NAMESPACE> <IDENTIFIER> "{" (NamespaceDefinition())* "}"
}

void DeclarationStatement() : {}
{
	Declaration() ";"
}


void ClassDefinition() :
{ Token name, classtoken, parentclassname = null; }
{
	classtoken = <CLASS> name = <IDENTIFIER> [ ":" parentclassname = <IDENTIFIER> ]
	"{" ClassBody() "}"
	{
	  OxClass newClass;
	  if (parentclassname == null)
	  	 newClass = file.addClass(name.image);
	  else
	  	 newClass = file.addClass(name.image, parentclassname.image);
	  if (classtoken.specialToken != null)
         if (classtoken.specialToken.beginLine != 1)
         newClass.setComment(classtoken.specialToken.image);
	  project.addSymbol(newClass);
	} [";"]
}

void ClassBody() : {}
{
	( ( LOOKAHEAD(MethodDeclaration()) MethodDeclaration() | MemberDeclaration() ) )*
}

void MethodDeclaration() : {}
{
	[<VIRTUAL>] [<STATIC>] ["~"] <IDENTIFIER> "(" [ ArgumentList() ] ")" ";"
}

void MemberDeclaration() : {}
{
	[<CONST>] [<STATIC>] <DECL> VariableDeclaration() (","  VariableDeclaration() )* ";"
}

void EnumDeclaration() : {}
{
	<ENUM> "{" [<IDENTIFIER> ("," <IDENTIFIER>)*] "}"
}

void ExternFunctionDeclaration() : {}
{
	<EXTERN> [<STRING_LITERAL>] <IDENTIFIER> "(" [ ArgumentList() ] ")"  ";"
}

void FunctionDeclaration() :{}
{
	[<STATIC>]
	(
	  LOOKAHEAD(4)
	  <IDENTIFIER> ("::") ["~" ] <IDENTIFIER>
|	  <IDENTIFIER> 
	)
    "(" [ ArgumentList() ] ")"  ";"
}

void FunctionDefinition() :
{ Token name, classname, t1 = getToken(1), t2;
  String methodPrefix = "";
  OxFunction func;}
{
	[<STATIC>]
	(
	  LOOKAHEAD(4)
	  classname = <IDENTIFIER> ("::") ["~" { methodPrefix = "~"; } ] name = <IDENTIFIER>
	  {
	  	 OxClass oxClass = file.getClass(classname.image);
		 if (oxClass == null) {
		    System.out.println("WARNING: Class " + classname.image + " was not yet defined.");
			oxClass = file.addClass(classname.image);
		 }
		 String methodName = classname.image + "::" + methodPrefix + name.image;
	     OxMethod newMethod = oxClass.addMethod(methodName);
	     if (classname.specialToken != null)
            if (classname.specialToken.beginLine != 1)
		    newMethod.setComment(classname.specialToken.image);
		 project.addSymbol(newMethod);
		 func = newMethod;
	  }
|	  name = <IDENTIFIER> 
	  {
	  	 OxFunction newFunction = file.addFunction(name.image);
	     if (name.specialToken != null)
            if (name.specialToken.beginLine != 1)
		    newFunction.setComment(name.specialToken.image);
		 project.addSymbol(newFunction);
		 func = newFunction;
	  }
	)
    "(" [ ArgumentList() ] ")" 
	{
	  t2 = getToken(0);

	  String decl = "";
	  for(; t1 != t2; t1 = t1.next)
	  	decl += t1.image + " ";
	  decl += t2.image;
	  func._declaration = decl;
	}
	CompoundStatement()
}

void ArgumentList() : {}
{
	"..." | 
	[<CONST>] <IDENTIFIER> [ "," ArgumentList() ]
}

void CompoundStatement() : {}
{
	"{"
		(Statement())*
	"}"
}

void SimpleStatement() : {}
{
	LOOKAHEAD(3)
	  Declaration() |
	  AssignmentExpression() ("," AssignmentExpression())* |
	  JumpStatement() 
}

void Statement() : {}
{
  	LOOKAHEAD(CompoundStatement()) CompoundStatement()
|	LOOKAHEAD(SimpleStatement()) SimpleStatement() ";"
|	IterationStatement()
|	SelectionStatement()
}

void JumpStatement() : {}
{
	( <CONTINUE>  |
	  <BREAK>  |
		  <RETURN> [ Expression() ]  )
}

void VariableDeclaration() : {}
{
	<IDENTIFIER> [ "=" AssignmentExpression() ]
}

void Declaration() : {}
{
	[<EXTERN>] [<CONST>] [<STATIC>] <DECL> VariableDeclaration() ("," VariableDeclaration())*
| EnumDeclaration() 	
}

void SelectionStatement() : {}
{
	( <IF> "(" Expression() ")" Statement() [ LOOKAHEAD(2) <ELSE> Statement() ] |
	  <SWITCH> "(" Expression() ")" Statement() )
}

void IterationStatement() : {}
{
	( <WHILE> "(" Expression() ")" Statement() |
	  <DO> Statement() <WHILE> "(" Expression() ")" ";" |
	  <FOR> "("
	  		[ SimpleStatement() ]
	  		";"
	  		[ Expression() ]
			";"
	  		[ SimpleStatement() ]
		")" Statement() )
}

void Expression() : {}
{
	AssignmentExpression() 
}

void AssignmentExpression() : {}  
{
	  "[" <IDENTIFIER> ("," <IDENTIFIER>)* "]" "=" AssignmentExpression() |
	  LOOKAHEAD(UnaryExpression() AssignmentOperator()) UnaryExpression() AssignmentOperator() AssignmentExpression() |
	  LOOKAHEAD(3) ConditionalExpression()
}

void AssignmentOperator() : {}
{
	( "=" | "*=" | "/=" | "+=" | "-=" | "~=" | "|=" | ".*=" | "./=" )
}

void ConditionalExpression() : {}
{
	LogicalORExpression()
		[ "?" AssignmentExpression()  ":" ConditionalExpression() |
		 ".?" AssignmentExpression() ".:" ConditionalExpression() ]
}

void LogicalORExpression() : {}
{
	LogicalDOTORExpression() [ "||" LogicalORExpression() ]
}

void LogicalDOTORExpression() : {}
{
	LogicalANDExpression() [ ".||" LogicalDOTORExpression() ]
}

void LogicalANDExpression() : {}
{
	LogicalDOTANDExpression() [ "&&" LogicalANDExpression() ]
}

void LogicalDOTANDExpression() : {}
{
	EqualityExpression() [ ".&&" LogicalDOTANDExpression() ]
}

void EqualityExpression() : {}
{
	RelationalExpression() [ ( "==" | "!=" | ".==" | ".!=" ) EqualityExpression() ]
}

void RelationalExpression() : {}
{
	VerticalConcatenationExpression() [ ( "<" | ">" | "<=" | ">=" | ".<" | ".>" | ".<=" | ".>=" ) RelationalExpression() ]
}

void VerticalConcatenationExpression() : {}
{
	HorizontalConcatenationExpression() [ "|" VerticalConcatenationExpression() ]
}

void HorizontalConcatenationExpression() : {}
{
	AdditiveExpression() [ "~" HorizontalConcatenationExpression() ]
}

void AdditiveExpression() : {}
{
	MultiplicativeExpression() [ ( "+" | "-" ) AdditiveExpression() ]
}

void MultiplicativeExpression() : {}
{
	UnaryExpression() [ ( "**" | "*" | "/" | ".*" | "./" ) MultiplicativeExpression() ]
}

void UnaryExpression() : {}
{
	( LOOKAHEAD(3) PowerExpression() |
	  UnaryOperator() UnaryExpression() 
	)
}

void UnaryOperator() : {}
{
	( "::" | "++" | "--" | "&" | "+" | "-" | "!" | "~" | <NEW> | <DELETE> )
}

void PowerExpression() : {}
{
	PostfixExpression() [ (  "^" | ".^" ) PowerExpression() ]
}

void PostfixExpression() : {}
{
	PrimaryExpression()  ( "[" [ RangeExpression() ] "]" |
	                      "(" [ LOOKAHEAD(ArgumentExpressionList() ) ArgumentExpressionList() ] ")" |
	  					  "." <IDENTIFIER> |
						  LOOKAHEAD(3) "->" <IDENTIFIER> "::" <IDENTIFIER> |
	  					  "->" <IDENTIFIER> |
	  					  "++" |
						  "'" [<IDENTIFIER>] |
	  					  "--" )*
}

void RangeExpression() : {}
{
	ConditionalExpression() [ ":" [ ConditionalExpression() ] ] |
	":" [ConditionalExpression() ]
}

void PrimaryExpression() : {}
{
	( LOOKAHEAD(2) <IDENTIFIER> "::" <IDENTIFIER> |
	  <IDENTIFIER> |
	  Constant() |
      "(" Expression() ")" )
}

void ArgumentExpressionList() : {}
{
	AssignmentExpression() ( "," AssignmentExpression() )*
}

void MatrixConstantElement() : {}
{
	"[" Constant() "]" "*" Constant() |
	LOOKAHEAD(3) Constant() ":" [ "[" Constant() "]" ] Constant() |
	Constant() |
	<IDENTIFIER>
}

void MatrixConstant() : {}
{
	"<" [MatrixConstantElement() ( [","|";"] MatrixConstantElement() )*] ">"
}

void ArrayConstant() : {}
{
	"{" [ Expression() ( "," Expression() )* ] "}"
}

void Constant() : {}
{
 LOOKAHEAD(2) ["+"|"-"] <FLOATING_POINT_LITERAL> | LOOKAHEAD(2) ["+"|"-"]  <INTEGER_LITERAL> |
 <CHARACTER_LITERAL> | <STRING_LITERAL> (LOOKAHEAD(1) <STRING_LITERAL>)* | MatrixConstant() | ArrayConstant()	| "." | LOOKAHEAD(2) ["+"|"-"] <INF> | <NAN>
}
